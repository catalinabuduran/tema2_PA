Am implementat codurile specifice problemelor in java.

Problema Numarare:
-am citit datele de intrare in functia "read-input"
-in functia get_result calculez numarul de lanturi elementare de la nodul 1 la N, comune in ambele grafuri, ajutandu ma de dp si sortarea
listelor de adiacenta(asta pentru a determina muchiile comune).
Pentru fiecare nod din graf am sortat listele de adiacenta din cele 2 grafuri, pentru a ma ajuta de binary search. Apoi pentru
fiecare vecin din lista de adiacenta a unui anumit nod din graful 1, de exemplu nodul "i", se face verificarea daca acesta exista in lista
de adiacenta a nodului i din graful 2. Daca se gaseste, se adauga in lista de adiacenta commonGraph. Apoi cu ajutorul dp, calculez lanturile
comune: vectorul dp va retine numarul de lanturi comune, am initializat dp[1]=1, deoarece exista un singur mod de a ajunge la nodul 1, care
reprezinta punct de start. Apoi am parcurs toti vecinii(din lista de adiacenta commonGraph) fiecarui nod si pentru fiecare am actuaalizat numarul
de lanturi comune care ajung la nodul j adaugand numarul de lanturi comune care ajung la nodul i. Cred ca O(NlogN) e complexitatea.

Problema Trenuri:
-am determinat numarul maxim de orase distincte cu ajutorul unei sortari topologice
-am construit un graf cand citiresc datele de intrare, in care fiecare nod este un oras si fiecare muchie este o cursa directa intre doua
orase. Am folosit HashMap pentru optimizare, avand acces rapid la lista de destinatii a fiecarui oras, deoarece fiecare lista de adiacenta contine orasele catre care exista cursa directa.In setul allCities am adaugat toate orasele existente, neduplicate.Apoi am ordonat nodurile intr-o ordine topologica cu ajutorul sortarii topologice, pentru a determina in mod corect directia calatoriei ai a asigura ca nu exista cicluri in graf. In "indexMap" am salvat orasul si indicele sau reprezentativ in ordinea topologica obtinuta mai sus, adica am creat o legatura intre oras si pozitia sa in ordinea topologica. Apoi cu ajutorul dp aflu distanta maxima. Am setat distanta de la orasul de start catre el insusi cu 0.Apoi parcurg toate orasele in ordinea topologica, pentru fiecare oras, verific daca exista deja o distanta cunoscuta catre el, daca da, verific daca are vecini in graf, apoi se itereaza prin vecini. Pentru fiecare vecin se actualizeaza distanta maxima catre acel vecin daca distanta actuala e mai mica decat distanta catre orasul curent + 1.Apoi afisez distanta maxima. Am implementat o functie care sa sorteze topologic: in nrMuchii mapez fiecare oras(nod) la nr de muchii care intra in el, initial fiind 0 pentru fiecare nod; apoi am iterat prin fiecare nod x din graf, apoi prin fiecare vecin al sau si am incrementat nr de muchii; apoi am adaugat intr-o coada toate nodurile care nu au muchii care intra in ele, acestea neavand noduri predecesoare si pot fi procesate primele. Cat timp coada nu e goala, extrag nodul x din coada si l adaug in newOrder. Dacx nodul x are vecini, iterez prin ei si decrementez nrMuchii. Complexitate O(N+M)

Problema Drumuri:
-pentru aceasta problema mi am declarat clasa staticÄƒ Edge, pentru a reprezenta o muchie a grafului orientat. Citind datele de la tastatura am creat graful in care am adaugat nodurile in ordinea de la tastatura(care reprezinta muchiile ce pleaca din a si ajung in b), dar mi am creat si un reverseGraph(salvez muchiile care pleaca de la b si ajung la a). Apoi am implementat functia Dijkstra, aplicand acest algoritm pentru a calcula  drumurile minime in graf, pornind de la un nod sursa.  Am initializat toate elementele din dist cu Long.MAX_VALUE, reprezentand distanta infinita initiala, sa stiu ca nodul nu a fost inca vizitat. Am folosit o coada de prioritati care sa ordoneze muchiile pe baza costului de la cel mai mic la cel mai mare. Apoi cat timp coada de prioritati nu este goala, retin si elimin intr-o variabila muchia cu cel mai mic cost din coada; obtin nodul in care ajunge muchia, dar si costul ei si daca costul actual este mai mare decat costul deja cunoscut pentru nodul ccurent, trece peste iteratie, deoarece am gasit deja un drum mai scurt spre el. Apoi iterez prin toate muchiile care pornesc de la nodul curent, obtin nodul cu o noua destinatie al muchiei curente, calculez noua distanta la nodul acesta prin nodul de la care am pornit initial, daca noua distanta este mai mica decat distanta cunoscuta pentru nodul new_dest, o actualizez, apoi adaug o noua muchie catre acesta cu costul nou obtinut in coada de prioritati. Apoi in getresult iterez prin toate nodurile grafului, verific daca din nodul i ajung la x, cat si la y si ca exista un drum de la i la z, calculez costul total al drumurilor x-i, y-i, i-z si verific daca e minim.Complexitate: O(3N+3MlogM) pt ca apelez de 3 ori dijkstra.